<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Js | Moshe's Blog]]></title>
  <link href="http://kolodny.github.io/blog/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://kolodny.github.io/blog/"/>
  <updated>2015-09-10T10:28:56-04:00</updated>
  <id>http://kolodny.github.io/blog/</id>
  <author>
    <name><![CDATA[Moshe Kolodny]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handling Optional Args in JS]]></title>
    <link href="http://kolodny.github.io/blog/blog/2014/12/01/handling-optional-args-in-js/"/>
    <updated>2014-12-01T10:18:32-05:00</updated>
    <id>http://kolodny.github.io/blog/blog/2014/12/01/handling-optional-args-in-js</id>
    <content type="html"><![CDATA[<p>Often times I find myself writing functions which have optional args, while it&rsquo;s generally a better idea to pass an options object instead for mutliple arguments, three (maybe four) can still be considered an acceptable <a href="http://en.wikipedia.org/wiki/Arity">arity</a>.</p>

<p>Let&rsquo;s take a simple signature and implement some optional args.</p>

<p><code>js
function require(name, deps, fn) {}
</code></p>

<p>The way I started to deal with cases like this is as follows:</p>

<p>```js
function require(name, deps, fn) {
  var args = [].slice.call(arguments);</p>

<p>  if (typeof args[0] !== &lsquo;string&rsquo;) {</p>

<pre><code>args.splice(0, 0, null);
</code></pre>

<p>  }</p>

<p>  if (!(args[1] instanceof Array)) {</p>

<pre><code>args.splice(1, 0, []);
</code></pre>

<p>  }</p>

<p>  if (typeof args[2] !== &lsquo;function&rsquo;) {</p>

<pre><code>args.splice(2, 0, function() {});
</code></pre>

<p>  }</p>

<p>  [name, deps, fn] = args; // <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></p>

<p>}
```</p>

<p>I find this the clearest way to deal with optional args and I find the logic very easy to follow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Evaling With Style]]></title>
    <link href="http://kolodny.github.io/blog/blog/2014/10/30/evaling-with-style/"/>
    <updated>2014-10-30T08:19:10-04:00</updated>
    <id>http://kolodny.github.io/blog/blog/2014/10/30/evaling-with-style</id>
    <content type="html"><![CDATA[<p>A couple of projects I&rsquo;ve been working on, required me to turn strings into functions (templating, custom require, <a href="https://github.com/kolodny/m2">mocha clone</a>) and it didn&rsquo;t seem like there was a good way to do it with things I needed in scope.</p>

<p>Let&rsquo;s take a look at a couple of ways to do it.</p>

<p>There&rsquo;s <a href="http://ejohn.org/blog/javascript-micro-templating/">John Resig&rsquo;s microtemplating way</a> which is something like this:</p>

<p>```js
var str = &lsquo;hello &lt;%= obj.name %>, upperized: &lt;%= obj.name.toUpperCase() %>&rsquo;;
var ctx = { name: &lsquo;Moshe&rsquo; };
var go = function(str) {
  return new Function(&lsquo;obj&rsquo;,</p>

<pre><code>[
  'var p = [];',
  'p.push(',
    '"' + str.replace(/&lt;%= (.*?) %&gt;/g, '", $1, "') + '"',
  ');',
  'return p.join("")',
].join('')
</code></pre>

<p>  )
}
console.log(go(str)(ctx))
```</p>

<p>The issue with this way is that this doesn&rsquo;t scale, since you have to keep adding more params of things you need scope for. For example if we wanted to add helper functions:</p>

<p>```js
var str = &lsquo;hello &lt;%= obj.name %>, upperized: &lt;%= helpers.up(obj.name) %>&rsquo;;
var helpers = {up: function(str) { return str.toUpperCase(); }};
var ctx = { name: &lsquo;Moshe&rsquo; };
var go = function(str) {
  return new Function(&lsquo;obj&rsquo;, &lsquo;helpers&rsquo;,</p>

<pre><code>[
  'var p = [];',
  'p.push(',
    '"' + str.replace(/&lt;%= (.*?) %&gt;/g, '", $1, "') + '"',
  ');',
  'return p.join("")',
].join('')
</code></pre>

<p>  )
}
go(str)(ctx, helpers)
```</p>

<p>You can see that this doesn&rsquo;t really work as more things are needed.</p>

<p>Another way is to use <code>with</code> to put things in scope:</p>

<p>```js
var str = &lsquo;hello &lt;%= obj.name %>, upperized: &lt;%= h.up(obj.name) %>&rsquo;;
var helpers = {up: function(str) { return str.toUpperCase(); }};
var ctx = { name: &lsquo;Moshe&rsquo; };
var go = function(str) {
  return new Function(&lsquo;obj&rsquo;, &lsquo;expose&rsquo;,</p>

<pre><code>[
  'with (expose) {',
    'var p = [];',
    'p.push(',
      '"' + str.replace(/&lt;%= (.*?) %&gt;/g, '", $1, "') + '"',
    ');',
    'return p.join("")',
  '}',
].join('')
</code></pre>

<p>  )
}
go(str)(ctx, {h:helpers})
```</p>

<p>This works really well but there&rsquo;s a <a href="http://jsperf.com/with-statement/4">huge performance hit from using <code>with</code></a></p>

<p>If you&rsquo;re using node there&rsquo;s a <a href="http://nodejs.org/api/vm.html">vm module</a> which is really what we&rsquo;re looking for, but I wanted something I could also use in the browser.</p>

<p>After playing around with this problem, I came up with the following solution:</p>

<p>```js
function eval2(str, context, expose) {
  var exposeKeys = [];
  var exposeValues = [];
  for (var i in expose) {</p>

<pre><code>if (Object.hasOwnProperty.call(expose, i)) {
  exposeKeys.push(i);
  exposeValues.push(expose[i]);
}
</code></pre>

<p>  }
  return (new Function(</p>

<pre><code>'return function(' + exposeKeys + '){return function(){' + str + '}.bind(this)}'
</code></pre>

<p>  ))().apply(context, exposeValues);
}
```</p>

<p>You would use something like that as follows:</p>

<p><code>js
var ctx = {};
var expose = {up: function(str) { return str.toUpperCase() }};
eval2('console.log(arguments)', ctx, expose)('Look! Even has args!')
</code></p>

<p>Let&rsquo;s go through how this works.</p>

<p>Consider this:</p>

<p>```js
var r = new Function(&lsquo;return function inner() {}&rsquo;);
console.log(r.toString()); // &lsquo;function anonymous() {\nreturn function inner() {}\n}&rsquo;
console.log(r().toString()) // &lsquo;function inner() {}&rsquo;</p>

<p>var s = new Function(&lsquo;return function(a,b,c){console.log(a,b,c)}&rsquo;);
console.log(s.toString()) // &lsquo;function anonymous() {\nreturn function(a,b,c){console.log(a,b,c)}\n} &rsquo;
console.log(s().toString()) // &lsquo;function (a,b,c){console.log(a,b,c)}&rsquo;
s()(&lsquo;aa&rsquo;, &lsquo;bb&rsquo;, &lsquo;cc&rsquo;) // logs &lsquo;aa&rsquo;, &lsquo;bb&rsquo;, &lsquo;cc&rsquo;
```</p>

<p>Now going to back to the way we use it:</p>

<p><code>js
var code = 'console.log(this)';
var ctx = {the: 'context'};
var fn = (new Function('return function() {' + code + '}'))().call(ctx);
</code></p>

<p>If you wanted to have some stuff in scope:</p>

<p><code>js
var code = 'log(this); hey(this.the)';
var ctx = {the: 'context'};
var params = ['log', 'hey']; // [].toString joins on comma by default so it just works
var applies = [function(str) { console.log(str) }, alert];
var fn = (new Function('return function(' + params + ') {' + code + '}'))().apply(ctx, applies);
</code></p>

<p>And if you wanted to curry it just wrap it in another function:</p>

<p><code>js
var code = 'log(this); hey(this.the)';
var ctx = {the: 'context'};
var params = ['log', 'hey']; // [].toString joins on comma by default so it just works
var applies = [function(str) { console.log(str) }, alert];
var fn = (new Function('return function(' + params + ') {return function(){' + code + '}.bind(this)}'))().apply(ctx, applies);
</code></p>

<p>I didn&rsquo;t really run any benchmarks but I suspect that this is pretty performant and once you wrap your head around it, is actually pretty simple.</p>

<p>Happy Coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Async Javascript Code in Sync Format - Part 1]]></title>
    <link href="http://kolodny.github.io/blog/blog/2014/06/26/semi-async-js/"/>
    <updated>2014-06-26T11:32:44-04:00</updated>
    <id>http://kolodny.github.io/blog/blog/2014/06/26/semi-async-js</id>
    <content type="html"><![CDATA[<p>Writing async code is hard when not done properly. However there are ways to make it a breeze. One of them is to use promises and not have to worry about code being async or not.</p>

<p>I was looking around at different things and came across <a href="https://github.com/koajs/koa">koa</a> and got inspired to try a similar idea.</p>

<p>The basic idea of Koa is that when you need some async functionality you yield an async thingy like a promise or something similar and then koa waits for it to resolve and then continues your program injecting the new value into the function.</p>

<p>Sounds complicated? Let&rsquo;s try an example (all examples will only run in FF unless Chrome decides to support generators)</p>

<p>Let&rsquo;s start with a simple generator.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/2QsBH/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>As you can see the syntax is <code>function *() {}</code> and you need to instantiate a generator before you can use it.
For more info on the basics of generators see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">MDN</a></p>

<p>A cool thing about generators is that you can inject a value back into the generator function like so:</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/2QsBH/1/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>You actually can&rsquo;t inject something into the first <code>.next()</code> call, if you try you get this error: <code>TypeError: attempt to send "a" to newborn generator</code></p>

<p>Using just these two concepts and the very basics about Promises, we can write something that:</p>

<ol>
<li>Runs a generator until control is given back</li>
<li>If result if promise like, then resolve it and inject the resolved value back to the generator</li>
<li>Rinse and repeat.</li>
</ol>


<p>Let&rsquo;s start to write just that. Here&rsquo;s what out program will look like:</p>

<p><div>
  <pre><code class='javascript'>function *program() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var rand;
rand = yield getRandAsync();
console.log('first time around = ' + rand);
rand = yield getRandAsync();
console.log('second time around = ' + rand);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;function getRandAsync() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return Promise.resolve(Math.random())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;run(program());</code></pre>
</div>
</p>

<p>Now all we need to do is write the <code>run</code> function:</p>

<p><div>
  <pre><code class='javascript'>function run(gen) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step();

function step(value) {
    var result = gen.next(value);
    if (result.value instanceof Promise) {
        result.value.then(step);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p>

<p>Putting that all together:</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/JHFd5/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>Now a couple of nice thigs to have. Let&rsquo;s assume that sometime in the future <code>getRandAsync</code> is changed to just return a value and not a promise, we should handle that:</p>

<p><div>
  <pre><code class='javascript'>function run(gen) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step();

function step(value) {
    var result = gen.next(value);
    if (result.value instanceof Promise) {
        result.value.then(step);
    } else if (!result.done) {
        step(result.value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p>

<p>Easy enough. Now how would we handle concurrent async functions? Well the Promise object has a method <code>all</code> which handles it nicely, we just need to utilize it (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a> ctrl+f <code>Promise.all</code>):</p>

<p><div>
  <pre><code class='javascript'>function run(gen) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step();

function step(value) {
    var result = gen.next(value);
    if (result.value instanceof Promise) {
        result.value.then(step);
    } else if (result.value instanceof Array) {
        Promise.all(result.value).then(step);
    } else if (!result.done) {
        step(result.value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p>

<p>Now we can yield an array of promises to <code>run</code> and <code>Promise.all</code> will handle them. <a href="http://kolodny.github.io/blog/blog/2014/04/23/future-proof-your-code-with-promises/">The great thing about <code>Promise.all</code> is that it will handle an array of non promises just as well</a></p>

<p>putting that all together we get a very powerfull way to write javascript:</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/XKYVB/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p><a href="https://gist.github.com/kolodny/6691380b57abd5b56251"><strong>Gist</strong></a></p>
]]></content>
  </entry>
  
</feed>
